// Generated by CoffeeScript 1.8.0
var exec, fs, path, serve_static;

serve_static = require('serve-static');

fs = require('fs');

path = require('path');

if (fs.exists == null) {
  fs.exists = require('path').exists;
}

exec = require('child_process').exec;


/*
`dojo([options])`
-----------------

Connect middleware exposing the Dojo Toolkit.

By default, Dojo releases are downloaded and extracted
inside the "/tmp" folder and are cached for later usages.
You may change this folder into a permanent location by
providing the option "repository".

Options include:
*   method        One of "release" or "git"
*   version       Dojo version
*   repository    Caching folder, default to "/tmp"
 */

module.exports = function(options) {
  var args, count, dir, finish, loading, plugin, submodule, submodules, tgz, url, _base, _finish, _i, _len;
  if (options == null) {
    options = {};
  }
  if (options.method == null) {
    options.method = 'release';
  }
  if (options.version == null) {
    options.version = '1.10.0';
  }
  if (options.repository == null) {
    options.repository = '/tmp';
  }
  loading = true;
  submodules = ['dojo', 'dijit', 'dojox', 'util'];
  if (options.mapping == null) {
    options.mapping = {};
  }
  args = [];
  switch (options.method) {
    case 'release':
      tgz = "" + options.repository + "/dojo-release-" + options.version + ".tar.gz";
      dir = "" + options.repository + "/dojo-release-" + options.version;
      url = "http://download.dojotoolkit.org/release-" + options.version + "/dojo-release-" + options.version + ".tar.gz";
      for (_i = 0, _len = submodules.length; _i < _len; _i++) {
        submodule = submodules[_i];
        if ((_base = options.mapping)[submodule] == null) {
          _base[submodule] = path.resolve(dir, submodule);
        }
        options.mapping[submodule] = path.resolve(dir, options.mapping[submodule]);
      }
      fs.exists(dir, function(exists) {
        var cmd;
        if (exists) {
          return finish();
        }
        cmd = "curl " + url + " -o " + tgz + " && tar -xzf " + tgz + " -C " + options.repository;
        return exec(cmd, function(err, stdout, stderr) {
          if (err) {
            return finish(err);
          }
          return finish(err);
        });
      });
      break;
    case 'git':
      count = 0;
      _finish = function() {
        if (++count !== 4) {
          return;
        }
        return finish();
      };
      submodules.forEach(function(submodule) {
        var checkout, clone, revision, _base1;
        revision = options["" + submodule + "_revision"] || 'HEAD';
        if ((_base1 = options.mapping)[submodule] == null) {
          _base1[submodule] = "git-" + submodule + "-" + revision;
        }
        options.mapping[submodule] = path.resolve(options.repository, options.mapping[submodule]);
        clone = function(next) {
          return fs.exists("" + options.mapping[submodule], function(exists) {
            var cmds;
            if (exists && revision !== 'HEAD') {
              return _finish();
            }
            if (exists) {
              return next();
            }
            url = "https://github.com/dojo/" + submodule + ".git";
            cmds = [];
            cmds.push("git clone " + url + " " + options.mapping[submodule]);
            cmds = cmds.join(' && ');
            return exec(cmds, function(err, stdout, stderr) {
              return next(err);
            });
          });
        };
        checkout = function(next) {
          var cmds;
          cmds = [];
          cmds.push("cd " + options.mapping[submodule]);
          cmds.push("git checkout " + revision);
          cmds = cmds.join(' && ');
          return exec(cmds, function(err, stdout, stderr) {
            return next(err);
          });
        };
        return clone(function(err) {
          if (err) {
            return finish(err);
          }
          return checkout(function(err) {
            if (err) {
              return finish(err);
            }
            return _finish();
          });
        });
      });
      break;
    default:
      throw new Error("Invalid method option \"" + options.method + "\")");
  }
  finish = function(err) {
    var arg, _j, _len1, _results;
    if (err) {
      throw err;
    }
    loading = false;
    _results = [];
    for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
      arg = args[_j];
      _results.push(plugin.apply(null, arg));
    }
    return _results;
  };
  plugin = function(req, res, next) {
    var app, sttc;
    if (loading) {
      return args.push(arguments);
    }
    app = /^\/(\w+)\/.*/.exec(req.url);
    if (app && submodules.indexOf(app[1]) !== -1) {
      app = app[1];
      req.url = req.url.substr(app.length + 1);
      sttc = serve_static(options.mapping[app]);
      return sttc(req, res, function() {
        req.url = "/" + app + req.url;
        return next();
      });
    } else {
      return next();
    }
  };
  return plugin;
};
